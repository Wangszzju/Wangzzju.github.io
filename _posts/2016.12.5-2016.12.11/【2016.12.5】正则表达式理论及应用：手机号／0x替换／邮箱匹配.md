## 1.背景 
最近正则表达式用得很多很多啊，包括精确匹配手机号／邮箱 等等，那么是时候来介绍一波了

## 2.理论

### 2.1匹配规则

* \d：匹配数字
* \w：匹配字母
* \s：匹配空格

那么怎么拓展呢？
* .匹配任意字符 
* ＊任意个，+为1或任意个，?表示0或1，{n-m}为n到m个字符
* []表示某个匹配字符的范围
* ^表示行开头，$表示行结尾
案例1:
> `\d{3}`匹配3个数字 `\s+` 表示一个及以上的空格  `\d{3,8}`表示3-8个字符

案例2:
> `[a-zA-Z\_\$][0-9a-zA-Z\_\$]{0, 19}`  表示1-20个（前面1个，后面最多19个）由大小写字母下划线_$开头的，后接数字／大小写字母／下划线_／$

案例3:
> ^js$ 精确匹配

### 2.2测试方法

* 切分split
例如忽略空格，split内部参数是切分符号，`[\s\,\;\.]`+/表示任意个包括“空格／逗号／分号／点号”的规则
```
"a,b,c   d  ,,e;f.g".split(/[\s\,\;\.]+/);  
```
* 分组：
  * 用括号表示分组。例如`/^(\d{3})-(\d{3,8})$/`;  表示第一组是3个数字，第二组是3-8个数字，中间的－不加入
  * `re.exec(string)`。re为匹配规则，
全局搜索g：更新lastIndex属性，比如`/^(\d{3})-(\d{3,8})$/g`，每次匹配完之后，会更新lastIndex，当
```
let s = 'JavaScript, VBScript, JScript and ECMAScript';
let re=/[a-zA-Z]+Script/g;

// 使用全局匹配:
re.exec(s); // ['JavaScript']
re.lastIndex; // 10

re.exec(s); // ['VBScript']
re.lastIndex; // 20

re.exec(s); // ['JScript']
re.lastIndex; // 29

re.exec(s); // ['ECMAScript']
re.lastIndex; // 44

re.exec(s); // null，直到结束仍没有匹配到
```
* 不能使用`/^...$/`，那样只会最多匹配一次
* 还有：忽略大小写i

## 3.应用

### 3.1邮箱
匹配的时候可以用[]和()来区分字符串的分块，例如验证email 地址：`let re = /^[\d\w.]+@[\w]+[\.][\w]+$/; `

或者提取email地址中的名字，例如提取出Tom Paris
```
let re = /^<(\w+\s\w+)>\s*(\w+@\w+\.\w+)$/`;
let r = re.exec('<Tom Paris> tom@voyager.org'); 
```

### 3.2 匹配和提取手机号
在天使后台第三期开发中，有一个“根据手机号搜索”的需求，需要提取出11位手机号，即把开头的+86等字符去掉，再作为输入值
```
let mobileJudge = /^\s*((\＋|\+)?86\s*)?(1[3-9][0-9]{9})$/
```
* `\s*`表示任意个空格
* `((\＋|\+)?86\s*)?`拆解：
  * `(\＋|\+)?`，中文或者英文状态下输入的加号，或者没有加号
  * `86\s*` 精确匹配86，后面可以跟上任意个空格
  * 结尾的?表示不存在这样的匹配也没事。

那么就要提取出来了
```
if (mobileJudge.test(q)) {
  //取出纯11位号码部分
  let qExec = mobileJudge.exec(q);   
  q = qExec[qExec.length - 1];  //其实取lastIndex也可以的
  params = { mobile: q };
  filterStatusText += `【按手机号搜索：${q}】`;
}
```

### 3.3 把个位数转换为0开头的

注意这个函数，a会得到一个个位数，例如8，现在要把它变成08
```
function format(a){
  return a.toString.replace(/^(\d)$/,'0$1')
}
```
此外还有必要解释一下replace方法
* 第一个参数是替换模式
* 第二个参数是替换之后的字符串,$1表示第一个与 regexp 中的第 1 个子表达式相匹配的文本，比如下面的$1就是指`\s*(\w+)`
举例：
```
name = "Doe, John";
name.replace(/(\w+)\s*, \s*(\w+)/, "$2 $1");
```
该函数的返回值就是被修改完成以后的值，这样8就成了08;

