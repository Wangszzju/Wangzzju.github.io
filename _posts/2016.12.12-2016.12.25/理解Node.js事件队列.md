### 1.背景
其实很早就想写点关于Node.js实现事件队列

### 2.解读

#### 2.1 单线程

* 首先，Node本身是多线程的，但是负责执行JavaScript的线程只有一个，所以称为"单线程"。
注意：发起函数和回调函数都挂载在主线程上面，比如下面的`fs.readFile`和`function(err,data)`匿名函数
```
fs.readFile('foo.txt', 'utf8', function(err, data) {
    console.log(data);
});
```
* 其次，其他线程负责处理其他任务，通过**消息**来实现任务

#### 2.2 观察者

我们来看上面的这一段代码，其目的很明显是读取`foo.txt`的内容，然后打印出来。  
首先，在这段代码里，已经让发起函数执行发起了，那么它就会去读取文件，但问题是，读取完了以后呢？谁来告诉我什么之后执行这个回调函数？  

这就是观察者的作用，如果基于事件订阅／发布，那么其内部原理是：在读取完毕之后，触发`end`事件，执行和`end`绑定好的回调函数

### 2.3 事件队列

如果一次性有很多个读取文件的请求怎么办？谁先谁后？

这就需要事件队列和事件循环了，文字解释较为难懂，先放上一张图：
![事件队列和循环](https://segmentfault.com/img/bVxLvF)

但是有人说了，如果某个任务B，要等到任务A的结果出来了才能执行，比如这样：
```
let content ;
fs.readFile('foo.txt', 'utf8', function(err, data) {
    content = data;
});
console.log(content);
```
这咋办？请参考`Promise`对象啦，它可以用`then`方法执行链式调用


### 3.尾声
其实异步的这个概念，在生活里还是蛮多的啦。  
上周一个去河东路的一家炸鸡翅店买炸鸡翅尖（打个广告，这家叫卤人甲，真的好吃），突然就理解了Node的异步编程概念。

整个过程的核心都在那张小票，这是node的请求对象。

  *  一个接待员负责将用户的请求做好封装，表现为：收款，打印双份小票作为token，一份交给用户，一份交给炸鸡翅的小哥。
  *  炸鸡翅的小哥把拿到的小票做成一个队列，按次序做出特定的产品来，并且通知观察者取产品，并且把小票给到观察者。。
  *  另一个接待员作为观察者，定期接收来自炸鸡翅小哥的消息，根据token，也就是小票，执行回调函数

一些猜想：
  *  白天业务量极低，经常在一个用户买完鸡翅以后，并没有下一个用户过来，所以白天很可能只有一个接待员，那就同时作为请求封装者和观察者。
  *  晚上业务队列很长，可以考虑设置并发啊……毕竟你好歹搞了个异步出来，不利用一下并发做性能提升，岂不是很浪费？
  *  炸鸡翅的过程可以分为：取炸鸡——油炸——出锅放佐料——打包。其中油炸的部分不会让人力资源锁死（也就是说我一边炸着鸡翅，一边还能取下一份炸鸡），且经过我目测，油炸油炸时间远远超过其他三个步骤的时间，因此对于这家店，多增加一个炸锅，不需要增加炸鸡翅的小哥人数，就可以应对夜晚订单高并发的场景。——但是隔壁的奶茶店就不一样了，做奶茶的全过程中，做奶茶的小哥，这一人力资源，是锁死的，所以对奶茶店来讲，在增加设备的同时，也要增加做奶茶的小哥人数啊。